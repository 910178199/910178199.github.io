<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python之ORM]]></title>
      <url>%2F2016%2F12%2F26%2FPython%E4%B9%8BORM%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding=utf-8 -*-'ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上'import mysql.connectorfrom sqlalchemy import ForeignKey'在Python中，最有名的ORM框架是SQLAlchemy'from sqlalchemy import Column, String, create_enginefrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy.ext.declarative import declarative_base# 创建对象的基类Base = declarative_base()# 创建表conn = mysql.connector.connect(host='localhost', user='root', password='password', database='test')cursor = conn.cursor()cursor.execute('create table if not exists users (id INTEGER PRIMARY KEY, name VARCHAR(20))')cursor.execute('create table if not exists book (id INTEGER PRIMARY KEY, name VARCHAR(20), user_id INTEGER )')cursor.close()# 定义USer对象class User(Base): # 表的名称 __tablename__ = 'user' # 表的结构 id = Column(String(20), primary_key=True) name = Column(String(20)) books = relationship('Book')class Book(Base): __tablename__ = 'book' id = Column(String(20), primary_key=True) name = Column(String(20)) # “多”的一方的book表是通过外键关联到user表的: user_id = Column(String(20), ForeignKey('user.id'))# 初始化数据库连接engin = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')# 创建DBsession类型DBsession = sessionmaker(bind=engin)'''create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名''''''1.往数据库添加一条数据'''# 添加记录session = DBsession()# #创建新User对象# bob = User(id=1,name='Bob')# session.add(bob)# session.commit()# 创建新Book对象# new_book_1 = Book(id=1,name='Book1',user_id = 1)# session.add(new_book_1)# session.commit()# new_book_2 = Book(id=2,name='Book2',user_id = 1)# session.add(new_book_2)# session.commit()# session.close()'''2.查询数据库中数据'''# #创建session对象# session = DBsession()# #创建Query查询，filter是where条件，最后调用one()返回唯一一行，调用all()则返回所有行# user = session.query(User).filter(User.id=='2').one()## #打印类型和对象的name属性# print('type',type(user))# print('name',user.name)# #关闭session# session.close()'ORM就是把数据库表的行与相应的对象建立关联，互相转换。''''ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。正确使用ORM的前提是了解关系数据库的原理。'''session = DBsession()user = session.query(User).filter(User.id == '1').one()print(user.name)print(user.books)session.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[aiohttp]]></title>
      <url>%2F2016%2F12%2F21%2Faiohttp%2F</url>
      <content type="text"><![CDATA[-- coding=utf-8 --asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。123456789101112131415161718192021222324252627282930import asynciofrom aiohttp import web'编写一个HTTP服务器'async def index(request): await asyncio.sleep(0.5) return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;')async def hello(request): await asyncio.sleep(0.5) text = '&lt;h1&gt;hello %s&lt;/h1&gt;' % request.match_info['name'] return web.Response(body=text.encode('utf-8'))async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/&#123;name&#125;', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000') return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))# 一直运行直到停止loop.run_forever()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[asyncio]]></title>
      <url>%2F2016%2F12%2F21%2Fasyncio%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding=utf-8 -*-'异步IO''''asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。'''#yield from 可以让我们方便地调用另一个generator,把asyncio.sleep(1)看成是一个耗时1秒#的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine#yield from将调用一个子协程（也就是在一个协程中调用另一个协程）并直接获得子协程的返回结果#当正在被主线程执行的的coroutine遇到 yield from语句时，当前coroutine会被挂起，#yield from 后面的coroutine 会被主线程执行。import asyncio@asyncio.coroutinedef hello(): print('Hello world') #异步调用yield from asyncio.sleep(1) r = yield from asyncio.sleep(1) print('Hello again')#获取EventLooploop = asyncio.get_event_loop()#执行coroutineloop.run_until_complete(hello())loop.close()import threadingimport asyncio@asyncio.coroutinedef hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks))loop.close()import asynciodef wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) reader, writer = yield from connect header = 'GET / HTTP/1.0\r\nHost: %s\r\n\r\n' % host writer.write(header.encode('utf-8')) yield from writer.drain() while True: line = yield from reader.readline() if line == b'\r\n': break print('%s header &gt; %s' % (host, line.decode('utf-8').rstrip())) writer.close()loop = asyncio.get_event_loop()tasks = [wget(host) for host in ['www.sina.con.cn','www.sohu.com','www.163.com']]loop.run_until_complete(asyncio.wait(tasks))loop.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Coroutine]]></title>
      <url>%2F2016%2F12%2F21%2FCoroutine%2F</url>
      <content type="text"><![CDATA[最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 Python对协程的支持是通过generator实现的。 在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。 但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。 12345678910111213141516171819202122def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 注意到consumer函数是一个generator，把一个consumer传入produce后： 首先调用c.send(None)启动生成器； 然后，一旦生产了东西，通过c.send(n)切换到consumer执行； consumer通过yield拿到消息，处理，又通过yield把结果传回； produce拿到consumer处理的结果，继续生产下一条消息； produce决定不生产了，通过c.close()关闭consumer，整个过程结束。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 最后套用Donald Knuth的一句话总结协程的特点： “子程序就是协程的一种特例。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[async/await]]></title>
      <url>%2F2016%2F12%2F21%2Fasync-await%2F</url>
      <content type="text"><![CDATA[用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。 从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。async/await: 把@asyncio.coroutine替换为async；把yield from替换为await。12345678910111213141516171819202122import asyncio@asyncio.coroutinedef hello(): print("Hello world!") r = yield from asyncio.sleep(1) print("Hello again!")loop = asyncio.get_event_loop()loop.run_until_complete(hello())# 使用async/awaitasync def hello(): print("Hello world!") r = await asyncio.sleep(1) print("Hello again!")loop = asyncio.get_event_loop()loop.run_until_complete(hello())loop.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用模板]]></title>
      <url>%2F2016%2F12%2F20%2F%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425from flask import Flask, request, render_templateapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def home(): return render_template('home.html')@app.route('/signin', methods=['GET'])def signin_form(): return render_template('form.html')@app.route('/signin', methods=['POST'])def signin(): username = request.form['username'] password = request.form['password'] if username == 'admin' and password == 'password': return render_template('signin-ok.html', username=username) return render_template('form.html', message='Bad username or password', username=username)if __name__=='__main__': app.run() 12345678910111213141516171819我们用&#123;&#123; name &#125;&#125;表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用&#123;% ... %&#125;表示指令。比如循环输出页码：&#123;% for i in page_list %&#125; &lt;a href="/page/&#123;&#123; i &#125;&#125;"&gt;&#123;&#123; i &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;如果page_list是一个list：[1, 2, 3, 4, 5]，上面的模板将输出5个超链接。除了Jinja2，常见的模板还有：Mako：用&lt;% ... %&gt;和$&#123;xxx&#125;的一个模板；Cheetah：也是用&lt;% ... %&gt;和$&#123;xxx&#125;的一个模板；Django：Django是一站式框架，内置一个用&#123;% ... %&#125;和&#123;&#123; xxx &#125;&#125;的模板。## 用templates不要变。其它的html模板文件全都放在这个文件夹里，flask会自动到这个文件夹里找模板。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Web框架]]></title>
      <url>%2F2016%2F12%2F20%2F%E4%BD%BF%E7%94%A8Web%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728'Flask简单使用'from flask import Flaskfrom flask import requestapp = Flask(__name__)@app.route('/',methods=['GET','POST'])def home(): return '&lt;h1&gt;Home&lt;h1&gt;'@app.route('/signin',methods=['GET'])def signin_from(): return '''&lt;form action="/signin" method="post"&gt; &lt;p&gt;&lt;input name="username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;button type="submit"&gt;Sign In&lt;/button&gt;&lt;/p&gt; &lt;/form&gt;'''@app.route('/signin',methods=['POST'])def signin(): #需要从request对象中读取表单内容 if request.form['username']=='admin' and request.form['password']=='password': return '&lt;h3&gt;Hello,admin&lt;/h3&gt;' return '&lt;h3&gt;Bad username or password&lt;h3/&gt;'if __name__=='__main__': app.run() 除了Flask，常见的Python Web框架还有： Django：全能型Web框架； web.py：一个小巧的Web框架； Bottle：和Flask类似的Web框架； Tornado：Facebook的开源异步Web框架。 小结有了Web框架，我们在编写Web应用时，注意力就从WSGI处理函数转移到URL+对应的处理函数，这样，编写Web App就更加简单了。 在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过request.form[‘name’]来获取表单的内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WSGI]]></title>
      <url>%2F2016%2F12%2F20%2FWSGI%2F</url>
      <content type="text"><![CDATA[WSGI接口 123456#客户端#返回HTTP响应的Body发送给浏览器def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) body = '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % (environ['PATH_INFO'][1:] or 'web') return [body.encode('utf-8')] 1234567891011#服务端# 从wsgiref模块导入:from wsgiref.simple_server import make_server# 导入我们自己编写的application函数:from user_WSGI_clicent import application# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:httpd = make_server('', 8000, application)print('Serving HTTP on port 8000...')# 开始监听HTTP请求:httpd.serve_forever() 小结无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。 复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MYSQL操作]]></title>
      <url>%2F2016%2F12%2F20%2FMYSQL%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122'MySql使用'import mysql.connectorconn = mysql.connector.connect( port=3306, user = 'root',password='password', charset='utf8',database='test')cursor = conn.cursor()#建表cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')#插入数据cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])print(cursor.rowcount)#提交事务conn.commit()cursor.close()#查询数据库内容cursor = conn.cursor()cursor.execute('select * from user where id = %s',('1',))v = cursor.fetchall()print(v)cursor.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQLite操作]]></title>
      <url>%2F2016%2F12%2F20%2FSQLite%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# -*- coding=utf-8 -*-'SQLite使用'import sqlite3,os#连接到SQLite数据库#如果文件不存在，就创建test.dbconn = sqlite3.connect('test.db')#创建一个Cursorcursor = conn.cursor()#执行SQL语句创建表cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')#插入条记录cursor.execute('insert into user (id, name) values (\'1\', \'Michael\')')#获取插入的行数print(cursor.rowcount)#关闭cursorcursor.close()#提交事务conn.commit()#关闭连接conn.close()# 查询表中信息conn = sqlite3.connect('test.db')cursor = conn.cursor()#查询语句cursor.execute('select * from user where id = ?',('1',))#获得查询结果v = cursor.fetchall()print(v)cursor.close()conn.close()#练习db_file = os.path.join(os.path.dirname(__file__), 'test.db')if os.path.isfile(db_file): os.remove(db_file)conn = sqlite3.connect('test.db')cursor = conn.cursor()cursor.execute('create table user(id varchar(20) primary key,name varchar(20),score int)')cursor.execute(r"insert into user values ('A-001','A','96')")cursor.execute(r"insert into user values ('A-002','A','64')")cursor.execute(r"insert into user values ('A-003','A','76')")cursor.close()conn.commit()conn.close()def get_score_in(low, high): ' 返回指定分数区间的名字，按分数从低到高排序 ' conn = sqlite3.connect('test.db') cursor = conn.cursor() cursor.execute('select * from user where score&gt;=? and score &lt;=? order by score',(low,high)) v = cursor.fetchall() print(v) cursor.close() conn.close()if __name__=='__main__': get_score_in(80, 95) get_score_in(60, 80) get_score_in(60, 100) print('pass') 小结SQLite的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用 在Python中操作数据库时，要先导入数据库对应的驱动，然后，通过Connection对象和Cursor对象操作数据。 要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。 如何才能确保出错的情况下也关闭掉Connection对象和Cursor对象呢？请回忆try:…except:…finally:…的用法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UDP编程]]></title>
      <url>%2F2016%2F12%2F20%2FUDP%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920# -*- coding=utf-8 -*-'UDP服务端'import socket#socket.SOCK_DGRAM指定为UDP连接s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)#绑定端口s.bind(('127.0.0.1',9999))print('UDP Start ...')while True: #接受数据 data,addr = s.recvfrom(1024) print('Received from %s:%s'% addr) s.sendto(b'Hello ,%s !'% data,addr) 123456789101112131415# -*- coding=utf-8 -*-'UDP客户端'import sockets = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)for data in [b'A',b'B',b'C']: #发送数据 s.sendto(data,('127.0.0.1',9999)) #接受数据 print(s.recv(1024).decode('utf-8'))s.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP编程]]></title>
      <url>%2F2016%2F12%2F19%2FTCP%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435# -*- coding=utf-8 -*-'TCP服务端'import socketimport timeimport threadings = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#绑定端口s.bind(('127.0.0.1',9999))#监听s.listen(5)print('Wait ...')def tcplink(sock,addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr)while True: #接受一个连接 sock,addr = s.accept() #创建新的线程来处理 t = threading.Thread(target=tcplink,args=(sock,addr)) t.start() 12345678910111213141516# -*- coding=utf-8 -*-import socket'客户端's = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#连接服务器s.connect(('127.0.0.1',9999))#接受消息print('----',s.recv(1024).decode('utf-8'))for data in [b'A',b'B',b'C']: #发送数据 s.send(data) print(s.recv(1024).decode('utf-8'))s.send(b'exit')s.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图形界面]]></title>
      <url>%2F2016%2F12%2F19%2F%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[Python支持多种图形界面的第三方库，包括： Tk wxWidgets Qt GTK 使用tk123456789101112131415161718192021222324252627282930313233'图形界面'from tkinter import *import tkinter.messagebox as messageboxclass Applicaction(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.pack() self.createWidgets() def createWidgets(self): self.helloLabel = Label(self, text='Hello World') self.helloLabel.pack() self.quitButton = Button(self, text='Quit', command=self.quit) #pack()方法把Widget加入到父容器中 self.quitButton.pack() self.nameInput = Entry(self) self.nameInput.pack() self.alertButton = Button(self,text='发送',command = self.hello) self.alertButton.pack() def hello(self): name = self.nameInput.get() or 'world' messagebox.showinfo('Message','Hello, %s'%name)app = Applicaction()# 设置标题app.master.title('Hello World')# 主消息循环app.mainloop()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[urllib]]></title>
      <url>%2F2016%2F12%2F19%2Furllib%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566'urllib提供url的相关方法'from urllib import request# 打开urlopenwith request.urlopen('https://api.douban.com/v2/book/2129650') as f: data = f.read() # 获取请求状态 print('Status:%s' % f.status) print('reason:%s' % f.reason) # 获取请求头 for k, v in f.getheaders(): print('%s %s' % (k, v)) # 获取请求内容 print('Data', data.decode('utf-8'))# 模拟浏览器发送GET请求req = request.Request('http://www.douban.com/')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')with request.urlopen(req) as f: print('Status %s' % f.status, f.reason) for k, v in f.getheaders(): print('%s %s' % (k, v)) print('Data:', f.read().decode('utf-8'))#Post请求from urllib import request, parseprint('Login to weibo.cn...')email = input('Email: ')passwd = input('Password: ')login_data = parse.urlencode([ ('username', email), ('password', passwd), ('entry', 'mweibo'), ('client_id', ''), ('savestate', '1'), ('ec', ''), ('pagerefer', 'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F')])req = request.Request('https://passport.weibo.cn/sso/login')req.add_header('Origin', 'https://passport.weibo.cn')req.add_header('User-Agent', 'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25')req.add_header('Referer', 'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F')with request.urlopen(req, data=login_data.encode('utf-8')) as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8'))#通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理import urllibproxy_handler = urllib.request.ProxyHandler(&#123;'http': 'http://www.example.com:3128/'&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password('realm', 'host', 'username', 'password')opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open('http://www.example.com/login.html') as f: print('Status:', f.status, f.reason) for k, v in f.getheaders(): print('%s: %s' % (k, v)) print('Data:', f.read().decode('utf-8'))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML解析]]></title>
      <url>%2F2016%2F12%2F19%2FHTML%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。 好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：123456789101112131415161718192021222324252627282930313233from html.parser import HTMLParserfrom html.entities import name2codepointclass MyHTMLParser(HTMLParser): def handle_starttag(self, tag, attrs): print('&lt;%s&gt;' % tag) def handle_endtag(self, tag): print('&lt;/%s&gt;' % tag) def handle_startendtag(self, tag, attrs): print('&lt;%s/&gt;' % tag) def handle_data(self, data): print(data) def handle_comment(self, data): print('&lt;!--', data, '--&gt;') def handle_entityref(self, name): print('&amp;%s;' % name) def handle_charref(self, name): print('&amp;#%s;' % name)parser = MyHTMLParser()parser.feed('''&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- test html parser --&gt; &lt;p&gt;Some &lt;a href=\"#\"&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;''') feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。特殊字符有两种，一种是英文表示的&nbsp;，一种是数字表示的&#1234;，这两种字符都可以通过Parser解析出来。 解析网页12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsfrom html.parser import HTMLParserclass MyHTMLParser(HTMLParser): bool_title = False bool_time = False bool_place = False bool_miss = True def __init__(self): HTMLParser.__init__(self) self.message = [] def handle_starttag(self, tag, attrs): if len(attrs) &gt; 0: if tag == "h3" and attrs[0][1] == "event-title": self.bool_title = True elif tag == "time" and attrs[0][0] == "datetime": self.bool_time = True elif tag == "span" and attrs[0][1] == "event-location": self.bool_place = True elif tag == "h3" and attrs[0][1] == "widget-title just-missed": self.bool_miss = False def handle_data(self, data): if self.bool_title and self.bool_miss: self.message.append([]) self.message[-1].append(data) self.bool_title = False if self.bool_time and self.bool_miss: self.message[-1].append(data) self.bool_time = False if self.bool_place and self.bool_miss: self.message[-1].append(data) self.bool_place = Falsedef homework(): parser = MyHTMLParser() html = requests.get("https://www.python.org/events/python-events/").text parser.feed(html) a = parser.message for x in a: print(x) print("=====================================") print("会议名：%s 会议时间：%s 会议地点：%s" % (x[0], x[1], x[2])) print("\n")if __name__ == "__main__": homework()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XML解析]]></title>
      <url>%2F2016%2F12%2F18%2FXML%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。 DOM vs SAX 操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 正常情况下，优先考虑SAX，因为DOM实在太占内存。 在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。 举个例子，当SAX解析器读到一个节点时：1&lt;a href="/"&gt;python&lt;/a&gt; 会产生3个事件： start_element事件，在读取时； char_data事件，在读取python时； end_element事件，在读取时。用代码实验一下：12345678910111213141516171819202122232425from xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object): def start_element(self, name, attrs): print('sax:start_element: %s, attrs: %s' % (name, str(attrs))) def end_element(self, name): print('sax:end_element: %s' % name) def char_data(self, text): print('sax:char_data: %s' % text)xml = r'''&lt;?xml version="1.0"?&gt;&lt;ol&gt; &lt;li&gt;&lt;a href="/python"&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/ruby"&gt;Ruby&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;'''handler = DefaultSaxHandler()parser = ParserCreate()parser.StartElementHandler = handler.start_elementparser.EndElementHandler = handler.end_elementparser.CharacterDataHandler = handler.char_dataparser.Parse(xml) 需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。 除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：123456L = []L.append(r'&lt;?xml version="1.0"?&gt;')L.append(r'&lt;root&gt;')L.append(encode('some &amp; data'))L.append(r'&lt;/root&gt;')return ''.join(L) 如果要生成复杂的XML呢？建议你不要用XML，改成JSON。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from xml.parsers.expat import ParserCreateclass WeatherSaxHandler(object): def __init__(self): self.db = &#123;'yweather:forecast': &#123;&#125;&#125; self.count = 0 def start_element(self, name, attrs): if name == 'yweather:location': self.db['yweather:location'] = attrs if name == 'yweather:forecast': self.count += 1 self.db['yweather:forecast'][self.count] = attrs # db['yweather:forecast']也是一个字典def parse_weather(xml): handler = WeatherSaxHandler() parser = ParserCreate() parser.StartElementHandler = handler.start_element parser.Parse(xml) result = &#123;"today": &#123;&#125;, "tomorrow": &#123;&#125;, "city": handler.db['yweather:location']['city'], "country": handler.db['yweather:location']['country']&#125; result["today"]["low"] = int(handler.db['yweather:forecast'][1]['low']) result["today"]["text"] = handler.db['yweather:forecast'][1]['text'] result["today"]["high"] = int(handler.db['yweather:forecast'][1]['high']) result["tomorrow"]["low"] = int(handler.db['yweather:forecast'][2]['low']) result["tomorrow"]["text"] = handler.db['yweather:forecast'][2]['text'] result["tomorrow"]["high"] = int(handler.db['yweather:forecast'][2]['high']) return result# 测试:data = r'''&lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;&lt;rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"&gt; &lt;channel&gt; &lt;title&gt;Yahoo! Weather - Beijing, CN&lt;/title&gt; &lt;lastBuildDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/lastBuildDate&gt; &lt;yweather:location city="Beijing" region="" country="China"/&gt; &lt;yweather:units temperature="C" distance="km" pressure="mb" speed="km/h"/&gt; &lt;yweather:wind chill="28" direction="180" speed="14.48" /&gt; &lt;yweather:atmosphere humidity="53" visibility="2.61" pressure="1006.1" rising="0" /&gt; &lt;yweather:astronomy sunrise="4:51 am" sunset="7:32 pm"/&gt; &lt;item&gt; &lt;geo:lat&gt;39.91&lt;/geo:lat&gt; &lt;geo:long&gt;116.39&lt;/geo:long&gt; &lt;pubDate&gt;Wed, 27 May 2015 11:00 am CST&lt;/pubDate&gt; &lt;yweather:condition text="Haze" code="21" temp="28" date="Wed, 27 May 2015 11:00 am CST" /&gt; &lt;yweather:forecast day="Wed" date="27 May 2015" low="20" high="33" text="Partly Cloudy" code="30" /&gt; &lt;yweather:forecast day="Thu" date="28 May 2015" low="21" high="34" text="Sunny" code="32" /&gt; &lt;yweather:forecast day="Fri" date="29 May 2015" low="18" high="25" text="AM Showers" code="39" /&gt; &lt;yweather:forecast day="Sat" date="30 May 2015" low="18" high="32" text="Sunny" code="32" /&gt; &lt;yweather:forecast day="Sun" date="31 May 2015" low="20" high="37" text="Sunny" code="32" /&gt; &lt;/item&gt; &lt;/channel&gt;&lt;/rss&gt;'''weather = parse_weather(data)assert weather['city'] == 'Beijing', weather['city']assert weather['country'] == 'China', weather['country']assert weather['today']['text'] == 'Partly Cloudy', weather['today']['text']assert weather['today']['low'] == 20, weather['today']['low']assert weather['today']['high'] == 33, weather['today']['high']assert weather['tomorrow']['text'] == 'Sunny', weather['tomorrow']['text']assert weather['tomorrow']['low'] == 21, weather['tomorrow']['low']assert weather['tomorrow']['high'] == 34, weather['tomorrow']['high']print('Weather:', str(weather))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[contextlib]]></title>
      <url>%2F2016%2F12%2F18%2Fcontextlib%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding=utf-8 -*-'contextlib:上下文库'class Query(object): def __init__(self, name): self.name = name def __enter__(self): print('Begin') return self def __exit__(self, exc_type, exc_value, traceback): if exc_type: print('Error') else: print('End') def query(self): print('Query info about %s...' % self.name)with Query('Bob') as q: q.query()# ---简化版---# 上下文管理器from contextlib import contextmanagerclass Quqry(object): def __init__(self, name): self.name = name def quary(self): print('Quary info about ...%s' % self.name)# @contextmanager使用上下文管理器@contextmanagerdef create_quary(name): print('Begin') q = Query(name) yield q print('End')with create_quary('HH') as q: q.query()# 练习代码@contextmanagerdef tag(name): print('&lt;%s&gt;' % name) yield print('&lt;%s&gt;' % name)with tag('h1'): print('hello,lijian')# 代码的执行顺序是：# with语句首先执行yield之前的语句，因此打印出&lt;h1&gt;；# yield调用会执行with语句内部的所有语句，因此打印出hello和world；# 最后执行yield之后的语句，打印出&lt;/h1&gt;。# 因此，@contextmanager让我们通过编写generator来简化上下文管理。# 如果一个对象没有实现上下文，我们就不能把它用于with语句。# 这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()#它的作用就是把任意对象变为上下文对象，并支持with语句。from contextlib import closingfrom urllib.request import urlopenwith closing(urlopen('https://www.python.org')) as page: for line in page: print(line)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[itertools]]></title>
      <url>%2F2016%2F12%2F18%2Fitertools%2F</url>
      <content type="text"><![CDATA[Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。1234567891011121314151617181920212223242526272829303132333435# -*- coding=utf-8 -*-'itertools 迭代工具'import itertools#无限迭代器：count(),#cycle()会把传入的一个序列无限重复下去#repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数# n = itertools.count(1)# for n in n:# print(n)# cs = itertools.cycle('ABC') # 注意字符串也是序列的一种# for c in cs:# print(c)ns = itertools.repeat('A', 3)for n in ns: print(n)#通过takewhile()等函数根据条件判断来截取出一个有限的序列na = itertools.count(1)ns = itertools.takewhile(lambda x:x &lt;=10,na)print(list(ns))#chain()把一组迭代对象串联起来，形成一个更大的迭代器for n in itertools.chain('jqa','xyz'): print(n)#groupby()把迭代器中相邻的重复元素挑出来放在一起：#忽略大小写for key,group in itertools.groupby('AAAaCCcCDDDSDS',lambda x:x.upper()): print(key,list(group)) ##小结itertools模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简要算法]]></title>
      <url>%2F2016%2F12%2F18%2F%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。 摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding=utf-8 -*-'haslib摘要算法'import hashlib# MD5加密md5 = hashlib.md5()md5.update('my name '.encode('utf-8'))md5.update('is lijian'.encode('utf-8'))print(md5.hexdigest())# SHA1加密sha1 = hashlib.sha1()sha1.update('my name'.encode('utf-8'))sha1.update('is lijian'.encode('utf-8'))print(sha1.hexdigest())# 练习def calc_md5(password): md5 = hashlib.md5() md5.update(str(password).encode('utf-8')) return md5.hexdigest()print(calc_md5('123456'))# 练习二：db = &#123; 'michael': 'e10adc3949ba59abbe56e057f20f883e', 'bob': '878ef96e86145580c38c87f0410ad153', 'alice': '99b1c2188db85afee403b1536010c2c9'&#125;def login(user, password): if calc_md5(password) == db[user]: return True else: return Falseprint(login('bob', 'abc999'))# 练习三：def get_md5(age): md5 = hashlib.md5() md5.update(str(age).encode('utf-8')) return md5.hexdigest()def register(username, password): r = get_md5(password + username + 'the-Salt') db[username] = r return rdef login(username,password): r = get_md5(password + username + 'the-Salt') if db[username]== r: print('True') else: print('False')print(register('123','123'))login('123','123')print(db)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[strucr]]></title>
      <url>%2F2016%2F12%2F18%2Fstruct%2F</url>
      <content type="text"><![CDATA[Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。 12345678910'struct:解决bytes和其他二进制数据类型转换'import structprint(struct.pack('&gt;I', 10240099))# pack的第一个参数是处理指令，'&gt;I'的意思是：# &gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。# 后面的参数个数要和处理指令一致。print(struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80'))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[base64]]></title>
      <url>%2F2016%2F12%2F17%2Fbase64%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021# -*- coding=utf-8 -*-'base64'import base64#编码b = base64.b64encode(b'binary\x00string')print(base64.b64encode(b'i\xb7\x1d\xfb\xef\xff'))#标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，#所以又有一种"url safe"的base64编码，其实就是把字符+和/分别变成-和_print(base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff'))print(b)#解码print(base64.urlsafe_b64decode('abcd--__'))de= base64.b64decode(b)print(de)#小结# Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[collections]]></title>
      <url>%2F2016%2F12%2F17%2Fcollections%2F</url>
      <content type="text"><![CDATA[collections是Python内建的一个集合模块，提供了许多有用的集合类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253'collections集合模块，提供了许多有用的集合类。'from collections import namedtuplePoint = namedtuple('Point', ['x', 'y', 'z'])p = Point(1, 2, 3)print(p.x, p.y, p.z)# namedtuple：是一个函数，它用来创建一个自定义的tuple对象，# 并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。print(isinstance(p, Point))print(isinstance(p, tuple))# deque：是为了高效实现插入和删除操作的双向列表，适合用于队列和栈from collections import dequeq = deque(['a', 'b', 'c'])q.append('x')# 在头部添加q.appendleft('y')# deque除了实现list的append()和pop()外，# 还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。print(q)q.popleft()q.pop()print(q)# defaultdict：使用dict时，如OrderedDict果引用的Key不存在，就会抛出KeyError。# 如果希望key不存在时，返回一个默认值from collections import defaultdictdf = defaultdict(lambda: 'defa')df['a'] = 1print(df['a'])#不存在返回默认值print(df['b'])#OrderedDict：在dict中保持key的顺序from collections import OrderedDictd = dict([('a', 1), ('b', 2), ('c', 3)])print(d)#保持插入顺序o = OrderedDict([('a', 1), ('b', 2), ('c', 3)])print(o)#Counter：计数器from collections import Counter#统计出现的次数c = Counter()for x in '1233': c[x] = c[x]+1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[datetime]]></title>
      <url>%2F2016%2F12%2F16%2Fdatetime%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding=utf-8 -*-'datetime 时间类'# datetime模块还包含一个datetime类，# 通过from datetime import datetime导入的才是datetime这个类。from datetime import datetime# 当前时间now = datetime.now()print(now)# 输入时间转换dt = datetime(2016, 1, 1, 20)print(dt)# datetime转换为timestamp(时间戳)# 时间转换为时间戳time = dt.timestamp()print(time)# 注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。# timestamp转换为datetime# 时间戳转换为时间d = datetime.fromtimestamp(time)print(d)# 转换为格林尼治时间utc = datetime.utcfromtimestamp(time)print(utc)# str转换为datetimeday = datetime.strptime('2016-12-12 12:12:12', '%Y-%m-%d %H:%M:%S')print(day)# datetime转换为strnow = datetime.now()print(now.strftime('%a,%b %d %H:%M'))# datetime加减# 加减可以直接用+和-运算符，不过需要导入timedelta这个类from datetime import datetime, timedelta,timezonenow = datetime.now()print(now)# 增加时间add = now + timedelta(hours=10)print(add)# 减时间jian = now - timedelta(days=1)print(jian)add = now + timedelta(days=2, hours=12)print(add)#本地时间转换为UTC时间#一个datetime类型有一个时区属性tzinfo，# 但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区tz_zone = timezone(timedelta(hours=8))now = datetime.now()print(now)#强制设置时区dt = now.replace(tzinfo=tz_zone)print(dt)#时区转换#我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间#零时区#时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。# 利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)print(utc_dt)# astimezone()将转换时区为北京时间:bj = utc_dt.astimezone(timezone(timedelta(hours=8)))print(bj)jp = utc_dt.astimezone(timezone(timedelta(hours=9)))print(jp) 小结 datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。 如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2016%2F12%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以： ‘00\d’可以匹配’007’，但无法匹配’00A’； ‘\d\d\d’可以匹配’010’； ‘\w\w\d’可以匹配’py3’； .可以匹配任意字符，所以： ‘py.’可以匹配’pyc’、’pyo’、’py!’等等。要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符： 来看一个复杂的例子：\d{3}\s+\d{3,8}。 我们来从左到右解读一下： \d{3}表示匹配3个数字，例如’010’； \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配’ ‘，’ ‘等； \d{3,8}表示3-8个数字，例如’1234567’。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配’010-12345’这样的号码呢？由于’-‘是特殊字符，在正则表达式中，要用’\’转义，所以，上面的正则是\d{3}-\d{3,8}。 但是，仍然无法匹配’010 - 12345’，因为带有空格。所以我们需要更复杂的匹配方式。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等； [a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量； [a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。 ^表示行的开头，^\d表示必须以数字开头。 $表示行的结束，\d$表示必须以数字结束。 你可能注意到了，py也可以匹配’python’，但是加上^py$就变成了整行匹配，就只能匹配’py’了。 re模块 有了准备知识，我们就可以在Python中使用正则表达式了。Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要特别注意： s = ‘ABC\-001’ # Python的字符串 对应的正则表达式字符串变成：‘ABC-001’因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了： s = r’ABC-001’ # Python的字符串 对应的正则表达式字符串不变：‘ABC-001’先看看如何判断正则表达式是否匹配： import rere.match(r’^\d{3}-\d{3,8}$’, ‘010-12345’) re.match(r’^\d{3}-\d{3,8}$’, ‘010 12345’) match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是： test = ‘用户输入的字符串’if re.match(r’正则表达式’, test): print(‘ok’)else: print(‘failed’)切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： ‘a b c’.split(‘ ‘)[‘a’, ‘b’, ‘’, ‘’, ‘c’]嗯，无法识别连续的空格，用正则表达式试试： re.split(r’\s+’, ‘a b c’)[‘a’, ‘b’, ‘c’]无论多少个空格都可以正常分割。加入,试试： re.split(r’[\s\,]+’, ‘a,b, c d’)[‘a’, ‘b’, ‘c’, ‘d’]再加入;试试： re.split(r’[\s\,\;]+’, ‘a,b;; c d’)[‘a’, ‘b’, ‘c’, ‘d’]如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： m = re.match(r’^(\d{3})-(\d{3,8})$’, ‘010-12345’)m m.group(0)‘010-12345’m.group(1)‘010’m.group(2)‘12345’如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。 提取子串非常有用。来看一个更凶残的例子： t = ‘19:05:30’m = re.match(r’^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$’, t)m.groups()(‘19’, ‘05’, ‘30’)这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： ‘^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$’对于’2-30’，’4-31’这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： re.match(r’^(\d+)(0)$’, ‘102300’).groups()(‘102300’, ‘’)由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0只能匹配空字符串了。 必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配： re.match(r’^(\d+?)(0*)$’, ‘102300’).groups()(‘1023’, ‘00’)编译 当我们在Python中使用正则表达式时，re模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配： import re 编译:re_telephone = re.compile(r’^(\d{3})-(\d{3,8})$’) 使用：re_telephone.match(‘010-12345’).groups()(‘010’, ‘12345’)re_telephone.match(‘010-8086’).groups()(‘010’, ‘8086’)编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分布式进程]]></title>
      <url>%2F2016%2F12%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%9B%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。 Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。 举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？ 原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import random, time, queuefrom multiprocessing import freeze_supportfrom multiprocessing.managers import BaseManager# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager): passdef return_task_queue(): global task_queue return task_queuedef return_result_queue(): global result_queue return result_queuedef test(): # 把两个Queue都注册到网络上, callable参数关联了Queue对象: QueueManager.register('get_task_queue', callable=return_task_queue) QueueManager.register('get_result_queue', callable=return_result_queue) # 绑定端口5000, 设置验证码'abc': manager = QueueManager(address=('127.0.0.1', 5000), authkey=b'abc') # 启动Queue: manager.start() # 获得通过网络访问的Queue对象: task = manager.get_task_queue() result = manager.get_result_queue() # 放几个任务进去: for i in range(10): n = random.randint(0, 10000) print('Put task %d...' % n) task.put(n) # 从result队列读取结果: print('Try get results...') for i in range(10): r = result.get(timeout=10) print('Result: %s' % r) # 关闭: manager.shutdown() print('master exit.')if __name__ == '__main__': freeze_support() test() 请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。 然后，在另一台机器上启动任务进程（本机上启动也可以）：1234567891011121314151617181920212223242526272829303132333435# task_worker.pyimport time, sys, queuefrom multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register('get_task_queue')QueueManager.register('get_result_queue')# 连接到服务器，也就是运行task_master.py的机器:server_addr = '127.0.0.1'print('Connect to server %s...' % server_addr)# 端口和验证码注意保持与task_master.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey=b'abc')# 从网络连接:m.connect()# 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 从task队列取任务,并把结果写入result队列:for i in range(10): try: n = task.get(timeout=1) print('run task %d * %d...' % (n, n)) r = '%d * %d = %d' % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print('task queue is empty.')# 处理结束:print('worker exit.') 任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。 现在，可以试试分布式进程的工作效果了。先启动task_master.py服务进程：123456789101112131415161718192021222324252627282930313233343536373839$ python3 task_master.py Put task 3411...Put task 1605...Put task 1398...Put task 4729...Put task 5300...Put task 7471...Put task 68...Put task 4219...Put task 339...Put task 7866...Try get results...task_master.py进程发送完任务后，开始等待result队列的结果。现在启动task_worker.py进程：$ python3 task_worker.pyConnect to server 127.0.0.1...run task 3411 * 3411...run task 1605 * 1605...run task 1398 * 1398...run task 4729 * 4729...run task 5300 * 5300...run task 7471 * 7471...run task 68 * 68...run task 4219 * 4219...run task 339 * 339...run task 7866 * 7866...worker exit.task_worker.py进程结束，在task_master.py进程中会继续打印出结果：Result: 3411 * 3411 = 11634921Result: 1605 * 1605 = 2576025Result: 1398 * 1398 = 1954404Result: 4729 * 4729 = 22363441Result: 5300 * 5300 = 28090000Result: 7471 * 7471 = 55815841Result: 68 * 68 = 4624Result: 4219 * 4219 = 17799961Result: 339 * 339 = 114921Result: 7866 * 7866 = 61873956 这个简单的Master/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。 Queue对象存储在哪？注意到task_worker.py中根本没有创建Queue的代码，所以，Queue对象存储在task_master.py进程中： 而Queue之所以能通过网络访问，就是通过QueueManager实现的。由于QueueManager管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如get_task_queue。 authkey有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果task_worker.py的authkey和task_master.py的authkey不一致，肯定连接不上。 小结Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。 注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ThreadLocal]]></title>
      <url>%2F2016%2F12%2F16%2FThreadLocal%2F</url>
      <content type="text"><![CDATA[ThreadLocal:解决函数中的传递问题123456789101112131415161718192021222324252627ThreadLocal帮你自动做这件事：import threading# 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print('Hello, %s (in %s)' % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')t1.start()t2.start()t1.join()t2.join()执行结果：Hello, Alice (in Thread-A)Hello, Bob (in Thread-B) ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 小结一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[多任务可以由多进程完成，也可以由一个进程内的多线程完成。Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下使用threading这个高级模块。 1234567891011121314151617181920212223242526# -*- coding=utf-8 -*-'多线程'# threading的使用import time, threadingdef loop(): print('thrad %s running' % threading.current_thread().name) n = 0 while n &lt; 5: n += 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended' % threading.current_thread().name)print('current thread %s' % threading.current_thread().name)# 子线程实例化# 传入线程loop，传入线程名称（不传入也可以）t = threading.Thread(target=loop, name='MyThread')t.start()# 线程同步t.join()print('thread %s ended' % threading.current_thread().name) Lock线程锁不加线程锁的问题：线程执行多条语句时，可能导致线程中断，从而导致多个线程把同一个对象的内容改乱了（导致内容不一致）threading.Lock()的好处？线程锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突1234567891011121314151617181920212223242526272829# 假定这是你的银行存款:balance = 0# 线程锁lock = threading.Lock()def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(100000): # 先获取锁 lock.acquire() try: change_it(n) finally: #释放线程锁 lock.release()t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance) 锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多进程]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[————-方式一 —————-fork():普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。123456789101112print('Process (%s) start...' % os.getpid())#fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）# ，然后，分别在父进程和子进程内返回。pid = os.fork()print(pid)if pid == 0: #pid代表子线程，ppid代表父线程 print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) multiprocessing模块提供了一个Process类来代表一个进程对象 ————-方式二—————-1234567891011121314151617#multiprocessing模块提供了一个Process类来代表一个进程对象#子线程执行代码def run_process(name): print('chile process ...',name,os.getpid())if __name__=='__main__': print('parent ...',os.getpid())#创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，# 用start()方法启动，这样创建进程比fork()还要简单。# join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 p = Process(target=run_process,args=('test',)) print('chile process start') p.start() p.join() print('chile process end') ————-方式三—————-12345678910111213141516171819202122#线程池#pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程：from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(8) for i in range(9): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All subprocesses done.') ————-子进程—————-很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。 subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。12345678910111213141516171819import subprocessprint('$ nslookup www.python.org')r = subprocess.call(['nslookup', 'www.python.org'])print('Exit code:', r)print('$ nslookup')p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b'set q=mx\npython.org\nexit\n')print(output.decode('utf-8'))print('Exit code:', p.returncode)#上面的代码相当于在命令行执行命令nslookup，然后手动输入：# set q=mx# python.org# exit 进程间通信Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。进程间通信 Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：123456789101112131415161718192021222324252627282930313233343536373839404142from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from queue.' % value)if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate()运行结果如下：Process to write: 50563Put A to queue...Process to read: 50564Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue. 在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。 小结在Unix/Linux下，可以使用fork()调用实现多进程。 要实现跨平台的多进程，可以使用multiprocessing模块。 进程间通信是通过Queue、Pipes等实现的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[序列化]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding=utf-8 -*-'序列化packling,反序列化unpackling''使用pickle模块实现'import pickleimport jsond = dict(name='name')#序列化到文件with open('pickle.txt','wb') as f : pickle.dump(d,f)#反序列化with open('pickle.txt','rb') as f: print(pickle.load(f))#序列化对象p = pickle.dumps(d)print(p)#反序列化p2 = pickle.loads(p)print(p2)#python转换为jsonD = dict(name='name',age='19',score = '100')#转换为jsonj = json.dumps(D)print(j)#转换为python对象j2 = json.loads(j)print(j2)#将json写入到文件with open('json.txt','w') as f: json.dump(D,f)#从文件中读取回python对象with open('json.txt','r') as f: print(json.load(f)) JSON进阶1234567891011121314151617181920212223242526272829303132class Student(object): def __init__(self,name,age,score): self.name = name self.age = age self.score = scores = Student('name',1,100)#json无法直接序列化class，报错# print(json.dumps(s))#简便方法：把任意class的实例变为dictprint(json.dumps(s,default=lambda obj:obj.__dict__))#可选参数default就是把任意一个对象变成一个可序列为JSON的对象def student2dict(stu): return &#123; 'name':stu.name ,'age':stu.age ,'score':stu.score &#125;s = json.dumps(s,default=student2dict)print(s)print('json',json.loads(s))#传入的object_hook函数负责把dict转换为Student实例：def dict2student(d): return Student(d['name'], d['age'], d['score'])json_str = '&#123;"age": 20, "score": 88, "name": "Bob"&#125;'print(json.loads(json_str, object_hook=dict2student)) 小结Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。 json模块的dumps()和loads()函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作文件和目录]]></title>
      <url>%2F2016%2F12%2F15%2F%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%2F</url>
      <content type="text"><![CDATA[‘操作文件和目录’12345678910111213141516171819202122import os#操作系统类型print(os.name)#详细的系统信息print(os.uname())#获取环境变量print(os.environ)#获取指定的环境变量print(os.environ.get('PATH'))print(os.environ.get('x','default'))#操作文件和目录#绝对路径print(os.path.abspath('.'))#在某个目录下创建一个新目录,把完整路径表示出来print(os.path.join('/Users/black/PythonProjects/Hello2','osCreate'))#创建# os.mkdir('/Users/black/PythonProjects/Hello2/osCreate')#删除os.rmdir('/Users/black/PythonProjects/Hello2/osCreate') 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：12345&gt;&gt;&gt; os.path.split('/Users/michael/testdir/file.txt')('/Users/michael/testdir', 'file.txt')#列出当前目录的所有文件l = [x for x in os.listdir('.') if os.path.isdir(x)]print(l) 列出所有py文件12l2 = [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]print(l2) 在目录下查找指定字符串123456789def enterdir(path,word): for x in os.listdir(path): subpath=os.path.join(os.path.abspath(path),x) if os.path.isdir(subpath): enterdir(subpath,word) else: if word in x: print(subpath)enterdir('/Users/black/PythonProjects/Hello2','debugging')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[StringIO和BytesIO]]></title>
      <url>%2F2016%2F12%2F15%2FStringIO%E5%92%8CBytesIO%2F</url>
      <content type="text"><![CDATA[StringIO很多时候，数据读写不一定是文件，也可以在内存中读写。 StringIO顾名思义就是在内存中读写str。 要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world! getvalue()方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。 BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\xe4\xb8\xad\xe6\x96\x87' 请注意，写入的不是str，而是经过UTF-8编码的bytes。 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')&gt;&gt;&gt; f.read()b'\xe4\xb8\xad\xe6\x96\x87' 小结StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IO操作]]></title>
      <url>%2F2016%2F12%2F15%2FIO%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：12with open('/path/to/file', 'r') as f: print(f.read()) 这和前面的try … finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：12for line in f.readlines(): print(line.strip()) # 把末尾的'\n'删掉 二进制文件前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可：123&gt;&gt;&gt; f = open('/Users/michael/test.jpg', 'rb')&gt;&gt;&gt; f.read()b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节 字符编码要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件：12&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')&gt;&gt;&gt; f.read() ‘测试’遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：1&gt;&gt;&gt; f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore') 写文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件：123&gt;&gt;&gt; f = open('/Users/michael/test.txt', 'w')&gt;&gt;&gt; f.write('Hello, world!')&gt;&gt;&gt; f.close() 你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险：12with open('/Users/michael/test.txt', 'w') as f: f.write('Hello, world!') 要写入特定编码的文本文件，请给open()函数传入encoding参数，将字符串自动转换成指定编码。 小结在Python中，文件读写是通过open()函数打开的文件对象完成的。使用with语句操作文件IO是个好习惯。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[调试]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%B0%83%E8%AF%95%2F</url>
      <content type="text"><![CDATA[1.断言（assert）：1234567def foo(s): n = int(s) assert n != 0, 'n is zero!' return 10 / ndef main(): foo('0') assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。 如果断言失败，assert语句本身就会抛出AssertionError 2.日志: logging和assert比，logging不会抛出错误，而且可以输出到文件123456789101112131415import logging#添加处理等级logging.basicConfig(level=logging.INFO)s = '0'n = int(s)logging.info('n = %d'% n)print(10/n)处理结果：$ python3 err.pyINFO:root:n = 0Traceback (most recent call last): File "err.py", line 8, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero 这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。 logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[错误处理]]></title>
      <url>%2F2016%2F12%2F15%2F%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[1234567891011121314try...except...finally...的错误处理机制，Python也不例外。抛出错误 raise# err_raise.pyclass FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / nfoo('0') 小结 Python内置的try…except…finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。 程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异常处理]]></title>
      <url>%2F2016%2F12%2F13%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[1234567891011121314try...except...finally...的错误处理机制，Python也不例外。抛出错误 raise# err_raise.pyclass FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError('invalid value: %s' % s) return 10 / nfoo('0') 小结Python内置的try…except…finally用来处理错误十分方便。出错时，会分析错误信息并定位错误发生的代码位置才是最关键的。 程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象高级编程之使用元类]]></title>
      <url>%2F2016%2F12%2F13%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[type()动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。 比方说我们要定义一个Hello的class，就写一个hello.py模块：123class Hello(object): def hello(self, name='world'): print('Hello, %s.' % name) 当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下： 12345678&gt;&gt;&gt; from hello import Hello&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class 'hello.Hello'&gt; type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。 我们说class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。 type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义：1234567891011&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数... print('Hello, %s.' % name)...&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class '__main__.Hello'&gt; 要创建一个class对象，type()函数依次传入3个参数： class的名称；继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。 metaclass除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。 metaclass，直译为元类，简单的解释就是： 当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。 但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。 连接起来就是：先定义metaclass，就可以创建类，最后创建实例。 所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。 metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。 我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法： 定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：12345# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) 有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：12class MyList(list, metaclass=ListMetaclass): pass 当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.new()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。 new()方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合。 测试一下MyList是否可以调用add()方法： 1234&gt;&gt;&gt; L = MyList()&gt;&gt;&gt; L.add(1)&gt;&gt; L[1]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[枚举]]></title>
      <url>%2F2016%2F12%2F12%2F%E6%9E%9A%E4%B8%BE%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324'枚举类'from enum import Enum,unique#枚举遍历Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name,N in Month.__members__.items(): print(name,'==&gt;',N,',',N.value)#unique保证没有重复值@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6print(Weekday.Sat)print(Weekday(1)) 可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。 小结Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定制类]]></title>
      <url>%2F2016%2F12%2F12%2F%E5%AE%9A%E5%88%B6%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[str：字符串 iter：如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个iter()方法，该方法返回一个迭代对象 getitem：要表现得像list那样按照下标取出元素，需要实现getitem()方法 getattr：Python还有另一个机制，那就是写一个getattr()方法，动态返回一个属性 call：可以直接对实例进行调用，可以自己调自己 -- coding=utf-8 --‘定制类’12345678910111213141516171819202122232425262728293031323334353637383940class Student(object): def __init__(self,name): self.name = name def __str__(self): return '结果：%s'% self.nameprint Student('name')#无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！class Chain(object): def __init__(self, path=''): self._path = path def __getattr__(self, path): return Chain('%s/%s' % (self._path, path)) def __str__(self): return self._path def __call__(self, name): return Chain('%s/%s' % (self._path, name)) __repr__ = __str__print Chain().status('123').user.timeline.list#callable判断是否可调用print callable(Chain())class Student(object): def __init__(self,name): self.name = name def __call__(self): print 'call',self.names = Student('Name')s() 小结Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档。https://docs.python.org/3/reference/datamodel.html#special-method-names]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多重继承]]></title>
      <url>%2F2016%2F12%2F12%2F%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[MixIn 在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。 为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。 小结由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。 只允许单一继承的语言（如Java）不能使用MixIn的设计。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用@property]]></title>
      <url>%2F2016%2F12%2F12%2F%E4%BD%BF%E7%94%A8-property%2F</url>
      <content type="text"><![CDATA[Python内置的@property装饰器就是负责把一个方法变成属性调用的：12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： s = Student()s.score = 60 # OK，实际转化为s.set_score(60)s.score # OK，实际转化为s.get_score()60s.score = 9999Traceback (most recent call last): …ValueError: score must between 0 ~ 100!注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 ‘property的用法：负责把一个方法变成一个属性来调用 set,get’12345678910111213141516171819202122class Student(): @property def scroe(self): return self._scroe @scroe.setter def scroe(self,value): if not isinstance(value,int): raise ValueError('scroe must be an int') if value&lt;0 or value&gt;100: raise ValueError('1~100') self._score = values = Student()#相当于sets.scroe = 10#相当于getprint s.scroes.scroe = 9999print s.scroe 小结@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面型对象高级编程之使用__slots__]]></title>
      <url>%2F2016%2F12%2F12%2F%E9%9D%A2%E5%9E%8B%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BD%BF%E7%94%A8__slots__%2F</url>
      <content type="text"><![CDATA[面型对象高级编程之使用 __slots____slots__1.为了给该实例绑定任何属性和方法 2.可以限制__slots__用于限制该类实例的属性与方法，不能限制类本身和继承类实例的属性与方法12345678910111213141516171819202122class Student(): # 用tuple定义允许绑定的属性名称 __slots__ = ('name','age') s = Student()#创建新实例 s.name = 'Name'#绑定属性 s.age = 'Age' #由于s没用方法到参数中，所以报错 #s.s = 's' #使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用 # ，对继承的子类是不起作用的： class Man(Student): pass m = Man() #m新创建的属性 m.s = 'a' #子类调用并不起作用，报错 print(m.s,m.name) 除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实例属性和类属性]]></title>
      <url>%2F2016%2F12%2F11%2F%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[由于Python是动态语言，根据类创建的实例可以任意绑定属性。 给实例绑定属性的方法是通过实例变量，或者通过self变量：123456class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：12class Student(object): name = 'Student' 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下： class Student(object):… name = ‘Student’…s = Student() # 创建实例sprint(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Studentprint(Student.name) # 打印类的name属性Students.name = ‘Michael’ # 给实例绑定name属性print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michaelprint(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Studentdel s.name # 如果删除实例的name属性print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student从上面的例子可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取对象信息]]></title>
      <url>%2F2016%2F12%2F11%2F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding=utf-8 -*-'获取对象信息'import types#使用 type(),判断类型是否相同print type(123)#一个变量指向函数或者类print type(abs)#两个数据类型是否相同print type(123)==type(345)#判断对象是否为函数def fn(): passprint type(fn)==types.FunctionTypeprint type(abs)==types.BuiltinFunctionTypeprint type(lambda x:x)==types.LambdaTypeprint type(x for x in range(1,10)) == types.GeneratorType#isinstance()#对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。class A(): print 'A'class B(): print 'B'a = A()b = B()#判断类是否一样print isinstance(a,A)print isinstance(b,B)print isinstance(a,B)#判断基本类型print isinstance(123,int)print isinstance('str',str)#判断一个变量是否是某些类型中的一种print isinstance([12,3,3],(list,tuple))print isinstance((12,2,3),(list,tuple))#使用dir()#获得一个对象的所有属性和方法print dir('f')class MyObject(): def __init__(self): self.x = 9 def power(self): return self.x *self.xobj = MyObject()#有x属性吗print hasattr(obj,'x')print hasattr(obj,'y')print obj.x#设置属性y,设置初始值print setattr(obj,'y',19)print hasattr(obj,'y')#获取y值,如果不存在可以随意设值print getattr(obj,'y')print getattr(obj,'z',-1)print hasattr(obj,'power')print getattr(obj,'power')一个正确的用法的例子如下：def readImage(fp): if hasattr(fp, 'read'): return readData(fp) return None]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[继承和多态]]></title>
      <url>%2F2016%2F12%2F11%2F%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding=utf-8 -*-'继承和多态''父类引用指向子类对象'class Animal(object): def run(self): print 'Animal run ...'#子类重写父类方法class Dog(Animal): def run(self): print 'Dog run ...'class Cat(Animal): def run(self): print 'Cat run ...'d = Dog()d.run()c = Cat()c.run()#判断一个变量是否是某个类型可以用isinstance()判断：a = list()#list类型b = Animal()c = Dog()#多态print isinstance(a,list)print isinstance(b,Animal)print isinstance(c,Animal)def run_twice(Animal): Animal.run() Animal.run()#传入父类run_twice(Animal())#传入子类run_twice(Dog())run_twice(Cat()) 静态语言 vs 动态语言对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 动态语言的特点：不需要继承Animal父类，也可以重写方法12345class M(object): def run(self): print 'M run ...'run_twice(M()) 小结继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[访问的限制]]></title>
      <url>%2F2016%2F12%2F11%2F%E8%AE%BF%E9%97%AE%E7%9A%84%E9%99%90%E5%88%B6%2F</url>
      <content type="text"><![CDATA[如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线，在Python中，实例的变量名如果以开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。1234567891011121314151617181920212223242526272829303132333435363738# -*- coding=utf-8 -*-'访问的限制'# __name表示私有参数class student(object): def __init__(self,name,age): self.__name = name self.__age = age def print_scroe(self): print ('%s : %s'%self.__name,self.__age) def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self,name): self.__name = names = student('A',100)#私有参数无法被调用#print s.__nameprint s.get_age()print s.get_name()s.set_name('B')print s.get_name()#仍然可以通过一下方法调用#不建议这么使用print s._student__name#并没有修改成功，毫无卵用s.__name = 'C'print s.get_name()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[类和实例]]></title>
      <url>%2F2016%2F12%2F11%2F%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 仍以Student类为例，在Python中，定义类是通过class关键字： class Student(object): passclass后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的： bart = Student()bart Student 可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性： bart.name = ‘Bart Simpson’bart.name‘Bart Simpson’由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的init方法，在创建实例的时候，就把name，score等属性绑上去：12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 注意到init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： bart = Student(‘Bart Simpson’, 59)bart.name‘Bart Simpson’bart.score59和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 小结类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响； 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据； 通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。 和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同： bart = Student(‘Bart Simpson’, 59)lisa = Student(‘Lisa Simpson’, 87)bart.age = 8bart.age8lisa.ageTraceback (most recent call last): File ““, line 1, in AttributeError: ‘Student’ object has no attribute ‘age’]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模板]]></title>
      <url>%2F2016%2F12%2F11%2F%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[请注意，每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。init.py可以是空文件，也可以有Python代码，因为init.py本身就是一个模块，而它的模块名就是mycompany。12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding=utf-8 -*-' a test module 使用模版'__author__ = 'Li'import sysdef test(): #sys模块有一个argv变量，用list存储了命令行的所有参数 #argv至少有一个元素，因为第一个参数永远是该.py文件的名称 args = sys.argv print args if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!')#Python解释器把一个特殊变量__name__置为__main__，# 而如果在其他地方导入该hello模块时，if判断将失败，因此，# 这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。if __name__=='__main__': test() 作用域：正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等； 类似xxx这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的author，name就是特殊变量，hello模块定义的文档注释也可以用特殊变量doc访问，我们自己的变量一般不要用这种变量名； 类似_xxx和xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，abc等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 小结：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[偏函数(Partial function)]]></title>
      <url>%2F2016%2F12%2F11%2F%E5%81%8F%E5%87%BD%E6%95%B0-Partial-function%2F</url>
      <content type="text"><![CDATA[Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）123456789101112131415161718192021222324252627# -*- coding=utf-8 -*-import functoolsprint int('123')print int('123',base=8)print int('123',16)#functools.partial就是帮助我们创建一个偏函数的int2 = functools.partial(int,base=2)print int2('1000000')print int2('1010101',base=10)#简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），# 返回一个新的函数，调用这个新函数会更简单。kw = &#123; 'base': 10 &#125;print int('10010', **kw)#返回最大值#默认值为10max2 = functools.partial(max,10)print max2(1,2,3,4)#相当于args = (1,2,3,4)print max(*args) 小结当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[装饰器]]></title>
      <url>%2F2016%2F12%2F10%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
      <content type="text"><![CDATA[本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：123@logdef now(): print('2015-3-25') 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志： now()call now():2015-3-25把@log放到now()函数的定义处，相当于执行了语句： now = log(now)由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。 wrapper()函数的参数定义是(args, *kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：1234567def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@log('execute')def now(): print('2015-3-25')执行结果如下：&gt;&gt;&gt; now()execute now():2015-3-25代码区域：# -*- coding=utf-8 -*-import functools#装饰器def now(): print '12-12-12'#赋值给变量f = nowf()#获取函数的名字print now.__name__print f.__name__def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper# 把@log放到now()函数的定义处，相当于执行了语句：# now = log(now)@logdef now(): print '12-3-3'now()#如果decorator本身需要传入参数，#那就需要编写一个返回decorator的高阶函数，写出来会更复杂。def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator#now = log('execute')(now)@log('exe')def now(): print 'hello'now()print now.__name__#只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。def log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print '123'now()def log(text): def de(func): @functools.wraps(func) def wrapper(*args,**kw): print '%s %s():' % (text, func.__name__) return func(*args,**kw) return wrapper return de@log('h')def now(): print 'hh'now()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[匿名函数]]></title>
      <url>%2F2016%2F12%2F10%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[12345678910111213141516#关键字lambda表示匿名函数，冒号前面的x表示函数参数。# 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。l = list(map(lambda x:x+x,[1,2,3]))print l#把匿名函数传给变量l2 = lambda x:x*xprint l2(5)#把匿名函数作为返回值def l3(x,y): return lambda :x*x+y*yl4 = l3(2,3)print l4()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数作为返回值]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
      <content type="text"><![CDATA[高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。123456789101112131415161718192021222324252627#返回函数def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum#返回函数print lazy_sum(1,2,3)#调用f()才是真正求和的结果f = lazy_sum(1,2,3)print f()#闭包def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1,f2,f3 = count()print f1(),f2(),f3() 全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。123456789101112131415#绑定前面的值#方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，#无论该循环变量后续如何更改，已绑定到函数参数的值不变def count2(): def sum(j): def g(): return j*j return g fs = [] for i in range(1,4): fs.append(sum(i)) return fsff,ff2,ff3 = count2()print ff(),ff2(),ff3() 小结一个函数可以返回一个计算结果，也可以返回一个函数。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python高级函数]]></title>
      <url>%2F2016%2F12%2F08%2Fpython%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1.变量可以指向函数123&gt;&gt;&gt; x = abs(-10)&gt;&gt;&gt; x10 2.函数名也是变量 那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！如果把abs指向其他对象，会有什么情况发生？12345&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'int' object is not callable 3.传入函数 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。一个最简单的高阶函数：12def add(x, y, f):return f(x) + f(y) 当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：1234x = -5y = 6f = absf(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11return 11 用代码验证一下：12&gt;&gt;&gt; add(-5, 6, abs)11 4.map()和reduce()函数1234567891011121314151617181920def f(x): return x * x# map的使用#参数一：方法名#参数二：传入值r = map(f, [1, 2, 3, 4, 5, 6, 7])print(list(r))#简写方法l = list(map(f,[1,2,3,4,5,67,7]))print(l)reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)列：from functools import reducedef str2int(s):def fn(x, y):return x * 10 + y def char2num(s):return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[s] return reduce(fn, map(char2num, s)) 5.filter(筛选函数) 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 把一个序列中的空字符串删掉，可以这么写：1234567# s.strip(rm) 删除s字符串中开头、结尾处空白（'\n','\t','\r'）# s.lstrip(rm) 删除s字符串中开头处空白# s.rstrip(rm) 删除s字符串中结尾处空白def not_empty(s):return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))# 结果: ['A', 'B', 'C'] filter()的作用是从一个序列中筛出符合条件的元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。 回数练习：12345678910def is_palindrome(n): I,m=n,0 while I: m=m*10+I%10 #//表示整除 I=I//10 return(n==m)output = filter(is_palindrome, range(1, 1000))print(list(output)) 6.sorted(排序)12345678910111213141516171819# sorted:排序#默认从小到大排序l = [1,2,3,-1,-2,-3]s = sorted(l)print(s)#传入第二个参数key:按照绝对值排序s2 = sorted(l,key=abs)print(s2)#字符串排序#'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面#转换成小写s3 = sorted(['bob', 'about', 'Zoo', 'Credit'],key=str.lower)print(s3)#传入第三个参数reverse：反向排序s4 = sorted(['bob', 'about', 'Zoo', 'Credit'],key=str.lower,reverse=True)print(s4)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python高级特性]]></title>
      <url>%2F2016%2F12%2F07%2Fpython%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501.Slice(切片)：取指定索引范围的操作（取指定范围的值）#取前十个数字print L[0:10]#取倒数十个数字print L[-10:]#取1-50之间的数字print L[1:50]#前十个数每两个取一个print L[:10:2]print L[1:100:2]#每五个取一个print L[::5]#全部输出print L[:]t = (1,2,3,4)[0:2]print t2.Iteration（迭代):python中通过 for ... in 实现# -*- coding=utf-8 -*-d = &#123;'a': 1, 'b': 2, 'c': 3&#125;#迭代keyfor k in d: print k#迭代valuefor v in d.values(): print v#迭代全部的值for k,v in d.items(): print k,v#如何判断一个对象是可迭代对象呢？# 方法是通过collections模块的Iterable类型判断：from collections import Iterables = isinstance('abc',Iterable)s2 = isinstance([1,2,3],Iterable)s3 = isinstance((1,2,3),Iterable)s4 = isinstance(set([1,2,3]),Iterable)s5 = isinstance(&#123;'a':'1','b':'2'&#125;,Iterable)#整数不能迭代s6 = isinstance(123,Iterable)print s,s2,s3,s4,s5,s6#多个对象迭代for x,y,z in [(1,1,1),(2,2,2),(3,3,3)]: print x,y,z 3.列表生成式1234567891011121314151617181920212223242526272829303132333435#生成listl = list(range(1,20))print lL= []for x in range(1,10): L.append(x * x)print L#简写方式l = [x * x for x in range(1,11)]print ll = [x*x for x in range(1,11) if x%2==0]print l#使用两层循环l = [x+y for x in 'abc' for y in 'cba']print l#显示列表import osl = [d for d in os.listdir('.')]print l#简写方式d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;l = [ x+'='+y for x,y in d.items()]print l#转换成小写L = ['Hello', 'World', 'IBM', 'Apple']l = [x.lower() for x in L]print l 4.generator(生成器)通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 可以通过next()函数获得generator的下一个返回值： 方法二:如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator1234567891011121314151617181920212223242526#generator生成器#第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：#斐波那契数列def fib(max): n,a,b = 0,0,1 while n&lt;max: yield b a,b = b,a+b n = n+1for x in fib(10): print x#yield语句返回，再次执行时从上次返回的yield语句处继续执行def odd(): print('step 1') yield 1 print('step 2') yield(3) print('step 3') yield(5)for x in odd(): print x 迭代器： 直接作用于for循环的数据类型有以下几种：一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。可以使用isinstance()判断一个对象是否是Iterable对象：12345678910111213141516171819202122&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False可以使用isinstance()判断一个对象是否是Iterator（可迭代的）对象：&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 生成器都是Iterator对象，但list、dict、str虽然是Iterable（可迭代），却不是Iterator(迭代器)。为什么？因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 把list、dict、str等Iterable变成Iterator可以使用iter()函数：1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 小结凡是可作用于for循环的对象都是Iterable类型； 凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数的参数]]></title>
      <url>%2F2016%2F12%2F06%2F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#参数组合# 位置参数：参数# 默认参数:设置初始值# 可变参数：*number# 命名关键字参数: 在参数 *# 关键字参数 : **kw# 函数的参数def add_end(L=None): if L is None: L = [] L.append('END') return Lprint(add_end())# 可变参数，在参数前加上 *# 由于参数个数不确定，# 我们首先想到可以把a，b，c……作为一个list或tuple传进来，# 这样，函数可以定义如下：def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum# 传入listprint(calc([1, 2, 3, 4]))# 传入tupleprint(calc((1, 2, 3, 4)))# 可变参数# 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号def calc2(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumprint(calc2())print(calc2(5, 6))# 传入一个list或tuple# Python允许你在list或tuple前面加一个*号，# 把list或tuple的元素变成可变参数传进去a = [1, 2, 3]b = (1, 2, 3)print(calc2(*a))print(calc2(*b))# 关键字参数，在参数前面加 **# 关键字参数允许你传入0个或任意个含参数名的参数，# 这些关键字参数在函数内部自动组装为一个dictdef person(name, age, **k): print(name, age, k)person('name', 1)person('a', '1', p='1', p1=2)extra = &#123;'a':'1','b':'2'&#125;person('name','age',city = extra['a'],b = extra['b'])#使用 **全部添加#不会影响到外面的 extraperson('name','age',**extra)#命名关键字参数#在参数中间加入 *,表示限定参数名称固定def person(name, age, *, city, job): print(name,age,city,job)person('name','age',city='bj',job='cxy')#如果参数中有可变参数#后面跟着的命名关键字参数就不再需要一个特殊分隔符 *了def person(name, age, *ages, city, job): print(name,age,ages,city,job)person('a','b',city='c',job='d')#如果参数有默认值时，不用传入def person(name, age, *, city='Beijing', job): print(name, age, city, job)person('a','b',job='job')#默认参数：def power(x, n=2): s = 1while n &gt; 0: n = n - 1 s = s * x return s#函数的参数： 默认参数必须指向不变对象！def add_end(L=None):if L is None: L = [] L.append('END') return L 小结：要注意定义可变参数和关键字参数的语法： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过args传入：func((1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过kw传入：func({‘a’: 1, ‘b’: 2})。 使用args和*kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数]]></title>
      <url>%2F2016%2F12%2F06%2F%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding:utf-8 -*-#python自带函数#函数#abs绝对值abs(10)a = abs(-100)print a#最大值m = max(1,2,3,4,5)print m#数据类型转换print int('120')print int(123.12)print str(123)print bool(1)print bool(0)#引用，相当于给abs起了一个别名a = absprint a(-1)#hex转成十六进制#isinstance参数类型检查#raise抛出异常def my_abs(x): if not isinstance(x,(int,float)): raise TypeError('Bad operand type') if x&gt;0: return x else: return -xprint my_abs(99)#pass为空函数，没有空函数的话报错c = 1if c&gt;18: pass]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dictionary和set]]></title>
      <url>%2F2016%2F12%2F06%2Fdictionary%E5%92%8Cset%2F</url>
      <content type="text"><![CDATA[dict:字典的简写dictionary:就是java中的map集合，以键值对的形式储存数据。12345678910111213141516171819202122232425262728d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;print(d['Bob'])#改d['Bob'] = 100print(d['Bob'])#判断值是否存在# 1.通过in来判断# 2.通过dice.get()来判断print('Bob' in d)print(d.get('Bod'))print(d.get('Bods',-1))#删除 pop(key)d.pop('Bob')print(d)#增加d['h'] = 'HHH'print(d)#删除全部# d.clear()# print('clear:',d)#遍历for x in d: print ("d[%s]=" %x,d[x]) list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。 dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key set:去除重复的值，和java中的相同1234567891011121314151617181920212223242526272829303132333435s = set([1,2,3])# -*- coding: utf-8 -*-s = (1,2,3)s2 = (1,[2,3])#s中的值是不可变的对象#将tuple放入dictmydict = &#123;s:'s'&#125;print mydict#将s2放入set#s2中的值[2,3]是可变的# myset = set([s2])# print mysetmyset = set([1,2,3])myset.add(4)print myset#删除myset.remove(1)print myseta = set([1,2,3])b = set([2,3,4])#并集print (a|b)#交集print (a&amp;b)#补集 b的补集print (a - b)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[循环]]></title>
      <url>%2F2016%2F12%2F05%2F%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-#for循环name = ['h','hh','hhh']for n in name: print n#循环累加sum = 0;for x in [1,2,3,4,5,6,7,8,9]: sum = sum+x print sum#生成整数序列mylis = list(range(10))print mylis#累加sum1 = 0;for x in range(101): sum1 = sum1+x print sum1#whlie循环sum2 = 0n = 99while n &gt; 0: sum2 = sum2 + n n = n-2print sum2#break直接退出循环#continue跳过，开始下一轮的循环]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[list和tuple]]></title>
      <url>%2F2016%2F12%2F05%2Flist%E5%92%8Ctuple%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: utf-8 -*-mylist = ['one','two','there']print mylist#长度print len(mylist)print mylist[0],mylist[1],mylist[2],mylist[-1]#mylist[-1]为最后一个元素#append在末尾追加数据mylist.append('end')print mylist#insert插入数据mylist.insert(0,'hh')print mylist#pop删除默认最后一个元素mylist.pop()print mylist#pop(i)删除指定位置数据mylist.pop(0)print mylist#替换数据mylist[0] = 'first'print mylist#不同数据v = ['str',123,4.0]print v#在插入一个listv1 = ['h','hh',v,'hhh']print v1#-----------------------------------------tuple：元组（元组的指向不变）每一个元素都不能改变值tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改#元组是（）包括的mytuple = ('one','two','there')print mytuple[0]#不能插入数据#mytuple[0] = 'hh'# print mytuplet = ()print t#可变的tuplet = ('a','b',['C','D'])t[2][0] = 'A't[2][1] = 'B'print t]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python字符串]]></title>
      <url>%2F2016%2F12%2F05%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[ord()获取字符串的整数表示chr()把编码转换为字符len()长度 ‘ABC’.encode(‘ascii’) 编码 b’ABC’.decode(‘ascii’) 解码 12345678格式化： %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 列：'Hi, %s, you have $%d.' % ('Michael', 1000000)]]></content>
    </entry>

    
  
  
</search>
